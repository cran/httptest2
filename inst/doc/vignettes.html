<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Writing Vignettes with APIs</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Writing Vignettes with APIs</h1>



<p>Package vignettes (like this!) are a valuable way to show how to use
your code. But if you’re demonstrating a package that communicates with
a remote API, it has been difficult to write useful vignettes.
<code>R CMD check</code> tests that package vignettes, when they are
dynamically generated by Sweave or R Markdown, can successfully be
rebuilt. If your API requires authentication to use, you’d need to
distribute your login credentials for the vignette to build, and that’s
generally not a good idea. Plus, building would require a stable network
connection, without which you might get spurious build failures and CRAN
submission rejections. Workarounds for these challenges, such as writing
static vignettes that only appear to do work, present other problems:
they’re lots of work to maintain and easily become out of sync with the
package.</p>
<p><code>httptest2</code> solves these problems. By adding as little as
one line of code to your vignette, you can safely record API responses
from a live session. These API responses are scrubbed of sensitive
personal information and stored in a subfolder in your
<code>vignettes</code> directory. Subsequent vignette builds, including
on continuous-integration services, CRAN, and your package users’
computers, use these recorded responses, allowing the document to
regenerate without a network connection or API credentials. To record
fresh API responses, delete the subfolder of cached responses and
re-run.</p>
<p>This vignette shows you how. To see an example in the wild, see the
<a href="https://enpiar.com/r/pivotaltrackR/articles/pivotaltrackR.html">introduction
vignette to <code>pivotaltrackR</code></a> (<a href="https://github.com/nealrichardson/pivotaltrackR/blob/master/vignettes/pivotaltrackR.Rmd">source</a>).
While this discussion is focused on package vignettes, the same behavior
should work in any R Markdown document.</p>
<div id="the-basics-start_vignette" class="section level1">
<h1>The basics: <code>start_vignette()</code></h1>
<p>Getting started is easy. At the beginning of your R Markdown
document, add this code chunk:</p>
<pre><code>`​``{r, include=FALSE}
library(httptest2)
start_vignette(&quot;vignette-name&quot;)
```</code></pre>
<p>changing <code>vignette-name</code> to something meaningful, such as
the name of your <code>.Rmd</code> file. <code>start_vignette()</code>
works by checking for the existence of a directory with the name you
provided. If no directory exists, the vignette proceeds making real API
requests and records the responses as fixtures inside the
<code>vignette-name</code> directory (that is, it calls
<code>start_capturing()</code>). If the directory does exists,
great—you’ve previously recorded API responses, so it uses them, loading
them with the same <code>use_mock_api()</code> mode you can use in your
test suite.</p>
<blockquote>
<p>Curious about how these recording and mocking contexts work? See
<code>vignettes(&quot;httptest2&quot;)</code> for an overview; it’s focused on
testing rather than vignettes, but the mechanics are the same.</p>
</blockquote>
<p>That’s about it! It is a good idea to add an
<code>end_vignette()</code> at the end of the document, like</p>
<pre><code>`​``{r, include=FALSE}
end_vignette()
```</code></pre>
<p>This turns off the request recording or mocking and cleans up the R
session state. It’s not necessary if you build each vignette in a clean
R process and quit on completion (everything is cleaned up when R
exits), but having the <code>end_vignette()</code> call is good in case
you build your documents in an interactive session.</p>
<p>Note that these code chunks have <code>include=FALSE</code>. This
prevents them from being printed in the resulting Markdown, HTML, PDF,
or whatever format document you produce. They’re doing work behind the
scenes, so you don’t need them to be shown to your readers.</p>
</div>
<div id="handling-server-state-changes" class="section level1">
<h1>Handling server state changes</h1>
<p>If all your vignette does is query an API to get data from it,
<code>start_vignette()</code> is all you need. Your actions don’t change
the state of anything on the server, so every time you make the same
request (at least within your current session), you get the same
response.</p>
<p>Sometimes, though, the purpose of your code is to alter server state:
you are creating a database entry, sending a tweet, or other similar
action. Suppose you are querying the Twitter API, and you first search
for the <code>#rstats</code> hashtag, then you send a tweet with that
hashtag, and finally you repeat your search. You’d expect the second
search to contain the tweet you just sent.</p>
<p>To make this work, before any code chunk that will alter server
state, call <code>change_state()</code>:</p>
<pre><code>`​``{r, include=FALSE}
change_state()
```</code></pre>
<p>When recording, this adds a new “layer” of recorded responses, and
when reading previously recorded responses, it changes to the next
layer.</p>
<p>For a working example, see the <code>pivotaltrackR</code> vignette.
It does a query, then creates a record on the server, modifies that
record, and then deletes it. All of this is captured in the vignette
data and is fully replayable.</p>
</div>
<div id="advanced-topics" class="section level1">
<h1>Advanced topics</h1>
<p>Because you’re recording API responses for replay offline, there are
a few additional considerations. First, you’ll want to make sure not to
expose your personal credentials or other private details in the cached
API responses. <code>httptest2</code> provides the ability to “redact”
responses you record, and by default, standard authentication methods
are redacted from recorded responses. It’s probable that you don’t need
to do anything further to have clean responses, but it’s worth
verifying.</p>
<p>Beyond credentials, there may be other attributes of API responses
that you want to modify, such as finding-and-replacing record ids with a
shorter or obfuscated value. Finally, depending on how long the URLs are
in the API requests you make, you may need to programmatically shorten
them if you’re planning on submitting your package to CRAN because it
requires file names to be 100 characters or less.</p>
<p>To modify these responses, you can provide a custom redacting
function. A good way to do this that works for both your test suite and
your vignettes is to put your custom function in
<code>inst/httptest2/redact.R</code> in your package, and it will be
automatically used whenever your package is loaded. See more about
redacting in <code>vignette(&quot;redacting&quot;)</code>.</p>
<p>If you don’t want to set these request/response processors globally
for your tests and vignettes, there are a couple of options. You can
<code>set_redactor()</code> in the code chunk where you call
<code>start_vignette()</code>. This is useful if you’re writing an R
Markdown document outside of the context of a package.</p>
<p>Alternatively, you can put vignette-specific setup and teardown code
for a package in <code>inst/httptest2/start-vignette.R</code> and
<code>inst/httptest2/end-vignette.R</code>, respectively, and like the
other <code>inst/httptest</code> files, these will be found and used
whenever your package is loaded. This is a good option when you have
more than one vignette and you want to share setup code across them
without copy-and-paste.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
